
<!doctype html>
<html lang="en">
  <head>
    <title>
      StructureMap - Nested Containers (Per Request/Transaction)</title>
    
<meta charset="utf-8"/>
<meta name="description" content="FubuDocs"/>
<meta name="author" content="FubuDocs"/>




<link href="/_content/styles/sons-of-obsidian.css" rel="stylesheet" type="text/css" />
<link href="/_content/styles/toastr.css" rel="stylesheet" type="text/css" />
<link href="/_content/styles/twitter/bootstrap.min.css" rel="stylesheet" type="text/css" />
<link href="/_content/styles/twitter/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" />
<link href="/_content/styles/toastr-responsive.css" rel="stylesheet" type="text/css" />
<link href="/_content/styles/fubudocs.core.css" rel="stylesheet" type="text/css" />
<link href="/_content/styles/fubudocs.theme.css" rel="stylesheet" type="text/css" />

<link media="screen" type="text/css" rel="stylesheet" href="http://fonts.googleapis.com/css?family=Oswald:400,300">

    
  </head>
  <body data-spy="scroll" data-target=".bs-docs-sidebar" position="relative">
      
    <div class="container">
      
      

<div class="row">
  <div class="span6">
    <p class="logo">
      <a href="/topics" title="Fubu" class="root-link"><span>Fubu</span></a>
      <a href="/" title="The original IoC/DI Container for .Net" class="project-logo"><span>StructureMap</span></a>
    </p>
  </div>
  <div class="span6">
    <div class="top-header text-right">
      <em>
        <em><a href="http://groups.google.com/group/structuremap-users?hl=en">Join our vibrant mailing list</a></em>
      </em>
      <div class="social">
        <a href="https://github.com/structuremap/structuremap" class="ico-github"><img alt="Github" src="/_content/images/github-icon.png" /></a>
      </div>
    </div>
  </div>
</div>
      

      <div id="nav-follow" class="navbar">
        <div class="navbar-inner">
          <div class="container">
            <ul class="nav"><li><a href="/" data-key="index">StructureMap &#187;</a></li><li><a href="/the-container" data-key="index">The Container &#187;</a></li><li class="active"><a href="/the-container/nested-containers" data-key="nested-containers">Nested Containers (Per Request/Transaction) &#187;</a></li></ul>
<ul class="nav" style="float:right"><li><a href="/the-container/profiles-and-child-containers" title="Profiles and Child Containers">Previous</a></li><li><a href="/the-container/working-with-generic-types" title="Working with Generic Types">Next</a></li></ul>
          </div>
        </div>
      </div>
      <hr/>
      <div class="row">
        
        

        <div class="row">
          <div class="span3 sidebar" data-spy="affix" data-offset-top="150" data-offset-bottom="200">
            
            <h3 class="half-margin">Topics</h3>
            <ul id="page-toc" class="nav nav-tabs nav-stacked bs-docs-sidebar">
            </ul>
            <br/>
            <h3>
              StructureMap v1.0.0
            </h3>

            <br/>
            <h3 class="no-margin">Next</h3>
<p><a href="/the-container/working-with-generic-types" data-key="working-with-generic-types">Working with Generic Types</a></p>
<h3 class="no-margin">Previous</h3>
<p><a href="/the-container/profiles-and-child-containers" data-key="profiles-and-child-containers">Profiles and Child Containers</a></p>
          </div>
          <div class="span9">

              <h1 class="no-margin">Nested Containers (Per Request/Transaction)</h1>
              <hr class="header-line topic-line"></hr>

            <!--Title: Nested Containers (Per Request/Transaction)-->
<!--Url: nested-containers-->
<p><em>Nested Container's</em> are a powerful feature in StructureMap for service resolution and clean object disposal in the 
context of short lived operations. Nested Container's were introduced in version 2.6, but greatly improved in both performance (100X reduction in the time to create a nested container in a large application) and <em>ahem</em> <a href="http://github.com/structuremap/structuremap/issues/3">lifecycle
mechanics</a> as a major goal of the 3.0 release.</p>

<p>The original use case and impetus for building this feature was a simplistic message handling system that dequeued
messages from a Sql Server table (please forget for a second the wisdom of using Sql Server as a queueing system), deserialized
the contents into a .Net object, then created the proper handler object for that message type and executed that handler -- all within
a single . </p>

<p>Why not just use <code>HttpContext</code> based lifecycles like we've always done in the past? Because <code>HttpContext</code> is not supported by the any
type of <a href="http://www.strathweb.com/2013/05/the-future-is-now-owin-and-multi-hosting-asp-net-web-applications/">OWIN</a> web host and will not be a part of ASP.Net vNext. Using a Nested Container per HTTP request is a better, lighterweight way
to scope services to an HTTP request without coupling your code to what will soon be legacy ASP.Net runtime code.</p>

<p>At the time of this document, Nested Container's per HTTP request or message are supported by frameworks like <a href="http://fubuworld.com/fubumvc">FubuMVC</a>, <a href="http://fubuworld.com/fubutransportation">FubuTransportation</a>,
<a href="http://masstransit-project.com">MassTransit</a>, 
ASP.Net MVC through the <a href="https://www.nuget.org/packages/StructureMap.MVC5/">StructureMap.MVC5</a> nuget package, and Web API with the <a href="https://www.nuget.org/packages/StructureMap.WebApi2/">StructureMap.WebApi2</a> nuget.</p>

<p>The StructureMap integrations for NancyFx and NServiceBus do not support StructureMap nested containers at this time but may in the future.</p>

<p><section><h4 id="creation" class="section-header">Creation</h4>
Creating a nested container is as simple as calling the <code>IContainer.GetNestedContainer()</code> method as shown below:</p>

<pre data-linenums="10" class="prettyprint lang-cs">
        [Test]
        public void creating_a_nested_container()
        {
            // From ObjectFactory, but please stop using ObjectFactory
            using (var nested = ObjectFactory.Container.GetNestedContainer())
            {
                // do stuff
            }

            // From an IContainer object
            var container = new Container();
            using (var nested = container.GetNestedContainer())
            {
                // do stuff
            }
        }
</pre>

<p></section></p>

<p><section><h4 id="lifecycles" class="section-header">Lifecycle Rules</h4></p>

<p>While StructureMap supports several object instance lifecycles out of the boxy, in idiomatic usage of StructureMap the only common lifecyles are:</p>

<ol>
<li><code>Transient</code> - The default lifecycle. A new object is created for a configured Instance on each request to the container</li>
<li><code>Singleton</code> - One instance is constructed and used over the entire Container lifetime</li>
</ol>

<p>In the context of a Nested Container however, the <code>Transient</code> scoping now applies to the Nested Container itself:</p>

<pre data-linenums="48" class="prettyprint lang-cs">
        [Test]
        public void nested_container_behavior_of_transients()
        {
            // &quot;Transient&quot; is the default lifecycle
            // in StructureMap
            var container = new Container(_ =&gt; {
                _.For&lt;IColor&gt;().Use&lt;Green&gt;();
            });

            // In a normal Container, a &quot;transient&quot; lifecycle
            // Instance will be built up once in every request
            // to the Container
            container.GetInstance&lt;IColor&gt;()
                .ShouldNotBeTheSameAs(container.GetInstance&lt;IColor&gt;());

            // From a nested container, the &quot;transient&quot; lifecycle
            // is tracked to the nested container
            using (var nested = container.GetNestedContainer())
            {
                nested.GetInstance&lt;IColor&gt;()
                    .ShouldBeTheSameAs(nested.GetInstance&lt;IColor&gt;());

                // One more time
                nested.GetInstance&lt;IColor&gt;()
                    .ShouldBeTheSameAs(nested.GetInstance&lt;IColor&gt;());
            }
        }
</pre>

<p><code>Instance's</code> scoped to anything but <code>Transient</code> are resolved as normal, but through the parent container:</p>

<pre data-linenums="29" class="prettyprint lang-cs">
        [Test]
        public void nested_container_usage_of_singletons()
        {
            var container = new Container(_ =&gt; {
                _.ForSingletonOf&lt;IColorCache&gt;().Use&lt;ColorCache&gt;();
            });

            var singleton = container.GetInstance&lt;IColorCache&gt;();

            // Singleton&#39;s are resolved from the parent container
            using (var nested = container.GetNestedContainer())
            {
                nested.GetInstance&lt;IColorCache&gt;()
                    .ShouldBeTheSameAs(singleton);
            }
        }
</pre>

<p>TODO(link to lifecycles)
</section></p>

<p><section><h4 id="overrides" class="section-header">Overriding Services from the Parent</h4>
A nested container is a new Container object that still retains access to the parent container that created it so that it can
efficiently share registrations, policies, and cached <em>build plan's</em>. <strong>There is no need to recreate registrations from the parent container
into the nested container and doing so makes StructureMap work less efficiently.</strong> You can, however, register register services into the nested container that override the parent container.</p>

<p>The <a href="http://fubuworld.com/fubumvc">FubuMVC web framework</a> uses a Nested Container per HTTP request. During an HTTP request, FubuMVC injects services
for the current HTTP request and response to a nested container before creating the actual services that will handle the request. The
FubuMVC mechanics are conceptually similar to this code sample:</p>

<pre data-linenums="142" class="prettyprint lang-cs">
        [Test]
        public void overriding_services_in_a_nested_container()
        {
            var container = new Container(_ =&gt; {
                _.For&lt;IHttpRequest&gt;().Use&lt;StandInHttpRequest&gt;();
                _.For&lt;IHttpResponse&gt;().Use&lt;StandInHttpResponse&gt;();
            });

            var request = new HttpRequest();
            var response = new HttpResponse();

            using (var nested = container.GetNestedContainer())
            {
                // Override the HTTP request and response for this
                // nested container
                nested.Configure(_ =&gt; {
                    _.For&lt;IHttpRequest&gt;().Use(request);
                    _.For&lt;IHttpResponse&gt;().Use(response);
                });

                var handler = nested.GetInstance&lt;HttpRequestHandler&gt;();
                handler.Request.ShouldBeTheSameAs(request);
                handler.Response.ShouldBeTheSameAs(response);
            }

            // Outside the nested container, we still have the original
            // registrations
            container.GetInstance&lt;IHttpRequest&gt;()
                .ShouldBeOfType&lt;StandInHttpRequest&gt;();

            container.GetInstance&lt;IHttpResponse&gt;()
                .ShouldBeOfType&lt;StandInHttpResponse&gt;();
        }
</pre>

<p>When handling requests for new services, a nested container first checks its own configuration.</p>

<div class="alert alert-info"><i class="icon-info-sign"></i>While the 3.0 version of nested containers acts like a <a href="http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">Chain of Responsibility</a> pattern to apply its own overrides, the earlier version
 of StructureMap made a complete copy of the underlying Container configuration. This crime against computer science was removed in 3.0 and hence, the 100X 
 improvement in the time it takes StructureMap to create a nested container.</div>

<p></section></p>

<p><section><h4 id="lazy" class="section-header">Lazy Resolution</h4>
<pre data-linenums="178" class="prettyprint lang-cs">
        public class Foo{}</p>

<pre><code>    public class FooHolder
    {
        public IContainer Container { get; set; }
        public Func&amp;lt;Foo&amp;gt; Func { get; set; }
        public Lazy&amp;lt;Foo&amp;gt; Lazy { get; set; }

        public FooHolder(IContainer container, Func&amp;lt;Foo&amp;gt; func, Lazy&amp;lt;Foo&amp;gt; lazy)
        {
            Container = container;
            Func = func;
            Lazy = lazy;
        }
    }

    [Test]
    public void service_location_and_container_resolution_inside_nested_containers()
    {
        var container = new Container();

        using (var nested = container.GetNestedContainer())
        {
            var holder = nested.GetInstance&amp;lt;FooHolder&amp;gt;();

            // The injected IContainer is the nested container
            holder.Container.ShouldBeTheSameAs(nested);

            // Func&amp;lt;T&amp;gt; and Lazy&amp;lt;T&amp;gt; values will be built by 
            // the nested container w/ the nested container
            // scoping
            var nestedFoo = nested.GetInstance&amp;lt;Foo&amp;gt;();

            holder.Func().ShouldBeTheSameAs(nestedFoo);
            holder.Lazy.Value.ShouldBeTheSameAs(nestedFoo);
        }
    }
</code></pre>

<p></pre></section></p>

<p><section><h4 id="profiles" class="section-header">Profiles</h4>
<pre data-linenums="78" class="prettyprint lang-cs">
        [Test]
        public void nested<em>container</em>from<em>profile</em>container()
        {
            var container = new Container(x =&gt; {
                x.For&lt;IColor&gt;().Use&lt;Red&gt;();</p>

<pre><code>            x.Profile(&amp;quot;Blue&amp;quot;, _ =&amp;gt; _.For&amp;lt;IColor&amp;gt;().Use&amp;lt;Blue&amp;gt;());
            x.Profile(&amp;quot;Green&amp;quot;, _ =&amp;gt; _.For&amp;lt;IColor&amp;gt;().Use&amp;lt;Green&amp;gt;());
        });

        using (var nested = container.GetProfile(&amp;quot;Blue&amp;quot;).GetNestedContainer())
        {
            nested.GetInstance&amp;lt;IColor&amp;gt;().ShouldBeOfType&amp;lt;Blue&amp;gt;();
        }

        using (var nested = container.GetNestedContainer(&amp;quot;Green&amp;quot;))
        {
            nested.GetInstance&amp;lt;IColor&amp;gt;().ShouldBeOfType&amp;lt;Green&amp;gt;();
        }
    }
</code></pre>

<p></pre></section></p>

<p><section><h4 id="disposing" class="section-header">Disposing Services</h4>
<pre data-linenums="101" class="prettyprint lang-cs">
        [Test]
        public void nested<em>container</em>disposal()
        {
            var container = new Container(_ =&gt; {
                // A singleton scoped service
                _.ForSingletonOf&lt;IColorCache&gt;().Use&lt;ColorCache&gt;();</p>

<pre><code>            // A transient scoped service
            _.For&amp;lt;IColor&amp;gt;().Use&amp;lt;Green&amp;gt;();
        });

        ColorCache singleton = null;
        Green nestedGreen = null;
        Blue nestedBlue = null;

        using (var nested = container.GetNestedContainer())
        {
            // Singleton&amp;#39;s are really built by the parent
            singleton = nested.GetInstance&amp;lt;IColorCache&amp;gt;()
                .ShouldBeOfType&amp;lt;ColorCache&amp;gt;();

            nestedGreen = nested.GetInstance&amp;lt;IColor&amp;gt;()
                .ShouldBeOfType&amp;lt;Green&amp;gt;();


            nestedBlue = nested.GetInstance&amp;lt;Blue&amp;gt;();
        }

        // Transients created by the Nested Container
        // are disposed, but no other lifecycle is
        // disposed
        nestedGreen.WasDisposed.ShouldBeTrue();
        nestedBlue.WasDisposed.ShouldBeTrue();

        // NOT disposed because it&amp;#39;s owned by
        // the parent container
        singleton.WasDisposed.ShouldBeFalse();
    }
</code></pre>

<p></pre></section></p>


<div class="alert alert-info"><i class="icon-info-sign"></i><code>ObjectFactory</code> will be marked as <code>[Obsolete]</code> soon and removed in a forthcoming 4.0 release. In practice, the static
service locator has too much potential to be misused and causes harmful coupling from application code to StructureMap infrastructure.</div>








<pre data-linenums="219" class="prettyprint lang-cs">
    public interface IColor{}
    public class Red : IColor{}

    public class Blue : IColor, IDisposable
    {
        public bool WasDisposed;

        public void Dispose()
        {
            WasDisposed = true;
        }
    }

    public class Green : IColor, IDisposable
    {
        public bool WasDisposed;

        public void Dispose()
        {
            WasDisposed = true;
        }
    } 

    public interface IColorCache{}

    public class ColorCache : IColorCache, IDisposable
    {
        public bool WasDisposed;

        public void Dispose()
        {
            WasDisposed = true;
        }
    }
</pre>
<pre data-linenums="256" class="prettyprint lang-cs">
    public interface IHttpRequest{}
    public interface IHttpResponse{}

    public class HttpRequest : IHttpRequest{}
    public class HttpResponse : IHttpResponse{}

    public class StandInHttpRequest : IHttpRequest{}
    public class StandInHttpResponse : IHttpResponse{}

    public class HttpRequestHandler
    {
        private readonly IHttpRequest _request;
        private readonly IHttpResponse _response;

        public HttpRequestHandler(IHttpRequest request, IHttpResponse response)
        {
            _request = request;
            _response = response;
        }

        public IHttpRequest Request
        {
            get { return _request; }
        }

        public IHttpResponse Response
        {
            get { return _response; }
        }
    }
</pre>








          </div>
        </div>
      </div>
    </div>

    <br></br>
    <hr></hr>
    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <ul class="nav"><li><a href="/" data-key="index">StructureMap &#187;</a></li><li><a href="/the-container" data-key="index">The Container &#187;</a></li><li class="active"><a href="/the-container/nested-containers" data-key="nested-containers">Nested Containers (Per Request/Transaction) &#187;</a></li></ul>
<ul class="nav" style="float:right"><li><a href="/the-container/profiles-and-child-containers" title="Profiles and Child Containers">Previous</a></li><li><a href="/the-container/working-with-generic-types" title="Working with Generic Types">Next</a></li></ul>
        </div>
      </div>
    </div>
    
    
    

<script type="text/javascript" src="/_content/scripts/jquery-1.8.2.min.js"></script>
<script type="text/javascript" src="/_content/scripts/prettify.js"></script>
<script type="text/javascript" src="/_content/scripts/bootstrap-prettify.js"></script>
<script type="text/javascript" src="/_content/scripts/fubudocs.js"></script>
<script type="text/javascript" src="/_content/scripts/jquery.nestable.js"></script>
<script type="text/javascript" src="/_content/scripts/toastr.js"></script>
<script type="text/javascript" src="/_content/scripts/twitter/bootstrap.min.js"></script>
<script type="text/javascript" src="/_content/scripts/diagnostics/bootstrap-scrollspy.js"></script>
<script type="text/javascript" src="/_content/scripts/fubudocs-tools.js"></script>
<script type="text/javascript" src="/_content/scripts/twitter/bootstrap-affix.js"></script>
<script type="text/javascript" src="/_content/scripts/topics.js"></script>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
    </p>
    <p>
      Powered by <a href="http://github.com/DarthFubuMVC/FubuDocs">FubuDocs</a>.
    </p>
  </div>
</footer>
  </body>
</html>